
<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    <meta http-equiv="Content-Type"content="text/html; charset=iso-8859-1">
    <link rel="manifest" href="/site.webmanifest">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
  <title>Bug findings with Type Erasure Mutation</title>
</head>


<body bgcolor="#ffffff">

<link type="text/css" rel="stylesheet" href="reports_style.css">

<h2>Bug findings with Type Erasure Mutation</h2>

<h3>Groovy</h3>

<ul>
<li>
<b>
#1 Local variable inference leads to incorrect type when having a complex parameterized type 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11087">https://issues.apache.org/jira/browse/GROOVY-11087</a>
<br>
<b>Date found</b>:
2023-06-08
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Main {
  static final void test() {
    Class<Class<Number>> d = null;
    var x = d.cast("");
    m(x);
  }
  static void m(Class<?> x) {}
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Variable type inference, Parameterized type, Parameterized class

<br>
<br>
</details>
</li>
<li>
<b>
#2 Incompatible generic argument when mixing diamond operator and "super" wildcard 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11082">https://issues.apache.org/jira/browse/GROOVY-11082</a>
<br>
<b>Date found</b>:
2023-06-06
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.function.*;
class Foo<T> {
  Foo(Supplier<? super T> x) {}
}
class Main {
  static final void test() {
    Supplier<CharSequence> func = null;
    Foo<StringBuffer> x = new Foo<>(func);
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Subtyping, Inheritance / Implementation of multiple interfaces, Wildcard type, Parameterized type, Parameterized class, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#3 Imprecise type for parameterized method when involving subtyping 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11074">https://issues.apache.org/jira/browse/GROOVY-11074</a>
<br>
<b>Date found</b>:
2023-05-26
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Main {
  static final void test() {
    Number x = 1;
    List<Number> y = m(x, 1);
  }
  static <T> List<T> m(T x, T y) { return null; }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Subtyping, Inheritance / Implementation of multiple interfaces, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#4 Cannot infer type of parameterized method when dealing with arrays  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11073">https://issues.apache.org/jira/browse/GROOVY-11073</a>
<br>
<b>Date found</b>:
2023-05-26
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2023-05-31
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Main {
  static final void test() {
    double[] x = Tuple.tuple(org.codehaus.groovy.runtime.ArrayGroovyMethods.max((double[][]) null, { -> 1 })).getV1();
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Array type, Overloading, Single Abstract Method (SAM), Lambda, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#5 STC takes the instantiation of a wrong type variable 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11065">https://issues.apache.org/jira/browse/GROOVY-11065</a>
<br>
<b>Date found</b>:
2023-05-18
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.*
import java.util.function.*;
class LockVisitor<X> {
  <T> T applyWriteLocked(Function<X, T> func) {return null;}
}
class Main {
  static final <X>void test() {
    Function<PropertyPermission, Collection<? extends X>> func = null;
    LockVisitor<PropertyPermission> rec = null;
    var x = rec.applyWriteLocked(func);
    X arg = null;
    TreeSet<X> y = new java.util.TreeSet<>(x)
    y.floor(arg)
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized type, Parameterized class, Type argument inference, Variable type inference, Wildcard type, Parameterized function

<br>
<br>
</details>
</li>
<li>
<b>
#6 Unable to construct Map with repeating key/value entries 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11050">https://issues.apache.org/jira/browse/GROOVY-11050</a>
<br>
<b>Date found</b>:
2023-05-10
<br>
<b>Status</b>:
In Progress


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Main {
  static final <V> void test() {
    V key = null;
    CharSequence value = null;
    java.util.Map.of(key, value); // succeeds
    java.util.Map.of(key, value, key, value); // fails
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#7 NPE when checking compatibility of method reference  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11026">https://issues.apache.org/jira/browse/GROOVY-11026</a>
<br>
<b>Date found</b>:
2023-04-26
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2023-04-29
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.function.*;
import java.util.List;
class Main {
  static final void test() {
        List<String> x = null;
        m(x::set);
  }
  static final <T, R> void m(BiFunction<T, R, R> y) {}
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Function reference, Single Abstract Method (SAM), Parameterized type, Parameterized class, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#8 NullPointerException in instruction selection when calling parameterized function whose type parameter has an upper bound corresponding to a SAM type  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11020">https://issues.apache.org/jira/browse/GROOVY-11020</a>
<br>
<b>Date found</b>:
2023-04-19
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2023-04-19
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.*;
import java.util.function.*;
class Main {
  static final void test(ArrayDeque<String> y) {
    m(y::addFirst);
  }
  static <C extends Consumer<String>> void m(C cl) {}
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Single Abstract Method (SAM), Function reference, Parameterized type, Parameterized class, Parameterized function, Bounded type parameter, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#9 Ambiguous method reference when expecting a SAM type 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11010">https://issues.apache.org/jira/browse/GROOVY-11010</a>
<br>
<b>Date found</b>:
2023-04-13
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.function.*;
class Main {
  static final void test() {
    from(Main::m);
  }
  static <K, V> void from(Function<K, V> f) {}
  static <V> void from(Supplier<V> f) {}
  static int m(String x) { return 1; }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Overloading, Parameterized function, Single Abstract Method (SAM), Parameterized type, Parameterized class, Type argument inference, Function reference

<br>
<br>
</details>
</li>
<li>
<b>
#10 Incompatible generic argument types when mixing diamond operator in parameterized function 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11004">https://issues.apache.org/jira/browse/GROOVY-11004</a>
<br>
<b>Date found</b>:
2023-04-07
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.*;
class Main {
  static final void test() {
    Map<Number, String> x = null;
    Map<Number, String> y = Collections.unmodifiableNavigableMap(new TreeMap<>(x));
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized function, Type argument inference, Parameterized type, Parameterized class

<br>
<br>
</details>
</li>
<li>
<b>
#11 Cannot find method with variable arguments when using fully qualified class names  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-11003">https://issues.apache.org/jira/browse/GROOVY-11003</a>
<br>
<b>Date found</b>:
2023-04-07
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2023-04-11
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Main {
  static final void test(java.util.List<Integer> p) {
    m(1, p);
  }
  static <T> void m(Integer x, java.util.List<T>... items) { }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized type, Parameterized class, Parameterized function, Variable argument

<br>
<br>
</details>
</li>
<li>
<b>
#12 Unexpected type mismatch when using super on a bounded type parameter 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10997">https://issues.apache.org/jira/browse/GROOVY-10997</a>
<br>
<b>Date found</b>:
2023-03-31
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.stream.*;
import java.util.function.*;
class Main {
  static final <Y, I extends Y> void test() {
    Stream<I> x = null;
    Consumer<Y> y = null;
    x.forEach(y);
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized function, Parameterized type, Parameterized class, Wildcard type, Bounded type parameter, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#13 Unexpected type mismatch when calling a parameterized function with a bounded type parameter 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10992">https://issues.apache.org/jira/browse/GROOVY-10992</a>
<br>
<b>Date found</b>:
2023-03-28
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.function.Supplier;
import java.util.function.BinaryOperator;
import java.util.stream.Stream;
class Main {
  static final <X extends Number> void test() {
    Supplier<Stream<X>> x = null;
    X y = null;
    BinaryOperator<X> z = null;
    X result = x.get().reduce(y, z);
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Bounded type parameter, Parameterized type, Parameterized class, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#14 STC rejects program when passing method reference in parameterized function  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10975">https://issues.apache.org/jira/browse/GROOVY-10975</a>
<br>
<b>Date found</b>:
2023-03-14
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2023-08-25
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.*;
class Main {
  static final void test() {
    Collection<Integer> x = null;
    WeakHashMap<Integer, Integer> y = null;
    new Hashtable<java.lang.IllegalStateException, Boolean>(Collections.min(x, y::put));
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Function reference, Parameterized type, Parameterized class, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#15 Type checking fails when casting method references 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10959">https://issues.apache.org/jira/browse/GROOVY-10959</a>
<br>
<b>Date found</b>:
2023-03-03
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.function.*;
import java.util.stream.*;
class Main {
  static final void test() {
    Foo<Object, String> x = null;
    Foo<String, String> y = null;
    BinaryOperator<String> z = null;
    final Object powdery = java.util.stream.Collectors.toConcurrentMap(
        x::m as Function<Object, String>,
        y::m as Function<String, String>,
        z
    );
  }
}
interface Foo<T1, T2> {
  T2 m(T1 x);
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Function reference, Parameterized function, Type argument inference, Single Abstract Method (SAM), Parameterized type, Parameterized class, Wildcard type

<br>
<br>
</details>
</li>
<li>
<b>
#16 Type inference yields a wrong type even if the type of the associated variable is given 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10913">https://issues.apache.org/jira/browse/GROOVY-10913</a>
<br>
<b>Date found</b>:
2023-01-22
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.*;
import java.util.stream.*;
class Test {
    void test() {
      Stream<Number> x = Arrays.stream(new Integer[]{1}).flatMap((y) ->
        Arrays.stream(new Long[]{(long) 1}));
    }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Subtyping, Inheritance / Implementation of multiple interfaces, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#17 Fail to infer type argument of parameterized function 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10870">https://issues.apache.org/jira/browse/GROOVY-10870</a>
<br>
<b>Date found</b>:
2022-12-14
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo<X> {}
class Test {
  static void test() {
    m(false, new Foo<>());
  }
  static <T> void m(T x1, Foo<T> x2) {}
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Type argument inference, Parameterized function, Parameterized type, Parameterized class

<br>
<br>
</details>
</li>
<li>
<b>
#18 NullPointerException in instruction selection phase when having parameterized method  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10869">https://issues.apache.org/jira/browse/GROOVY-10869</a>
<br>
<b>Date found</b>:
2022-12-14
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-12-17
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo<T> {
  Foo(T x) {}
  <T extends Short> T m(T x) {
    x
  }
}
class Test {
  static final void test() {
    Foo<Integer> tmp = new Foo<Integer>(-76);
    boolean cond = 5.0 > tmp.m(new Foo<Integer>(95).m(null));
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Bounded type parameter, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#19 Crash with arity generics parameter mismatch during the instruction selection phase  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10847">https://issues.apache.org/jira/browse/GROOVY-10847</a>
<br>
<b>Date found</b>:
2022-11-18
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-11-19
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<D, I> {}
class B {
  <T extends A<Character, Boolean>, X extends T>void m(T p1, X p2) {}
}
public class Test {
  void test() {
    A<Character, Boolean> x = null;
    (new B()).m(x, new A<>());
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized function, Type argument inference, Parameterized type, Parameterized class, Bounded type parameter

<br>
<br>
</details>
</li>
<li>
<b>
#20 Incompatible generic argument types when using wildcards  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10754">https://issues.apache.org/jira/browse/GROOVY-10754</a>
<br>
<b>Date found</b>:
2022-09-08
<br>
<b>Status</b>:
Resolved
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2023-04-28
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {}
class B extends A<Boolean> {}
class C<T extends A<Boolean>, U extends T> {
  C(T x, U v) {}
}
class Test {
  void test(B x, B y) {
    C<? extends B, ? extends B> z = new C<>(x, y);
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Wildcard type, Parameterized type, Parameterized class, Type argument inference, Bounded type parameter

<br>
<br>
</details>
</li>
<li>
<b>
#21 Resolving wrong overloaded method?  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10720">https://issues.apache.org/jira/browse/GROOVY-10720</a>
<br>
<b>Date found</b>:
2022-08-08
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-08-08
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.Arrays;
class Test {
    void test() {
      Double[] x = null;
      var y = Arrays.stream(x).map(d -> "fda").findFirst();
    }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Overloading, Array type, Primitive type, Parameterized function

<br>
<br>
</details>
</li>
<li>
<b>
#22 Incompatible generic argument types when using wildcards 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10754">https://issues.apache.org/jira/browse/GROOVY-10754</a>
<br>
<b>Date found</b>:
2022-09-08
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {}
class B extends A<Boolean> {}
class C<T extends A<Boolean>, U extends T> {
  C(T x, U v) {}
}
class Test {
  void test(B x, B y) {
    C<? extends B, ? extends B> z = new C<>(x, y);
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Type argument inference, Parameterized class, Parameterized type, Bounded type parameter, Inheritance / Implementation of multiple interfaces

<br>
<br>
</details>
</li>
<li>
<b>
#23 Unable to infer type argument from the parameter type of a lambda  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10699">https://issues.apache.org/jira/browse/GROOVY-10699</a>
<br>
<b>Date found</b>:
2022-07-21
<br>
<b>Status</b>:
Resolved
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-07-24
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.function.Function;
import java.util.function.Consumer;
import java.util.function.Supplier;
class A<T> {
  A(C<T> x) {}
}
class C<T> {
  C(T x ) {}
}
class B<X> {
  B(Consumer<X> x) {}
}
class D<X> {
  D(Supplier<X> x) {}
}
class Test {
  void test() {
    A<String> x = new A<>(new C<>("str")); // type inference works (type inferred based on the constant "str")
    D<String> z = new D<>(() -> "fda"); // type inference works (type inferred based on the return type of the lambda)
    B<String> y = new B<>((String e) -> {return;} ); // type inference doesn't work
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Type argument inference, Parameterized class, Lambda, Single Abstract Method (SAM), Parameterized type

<br>
<br>
</details>
</li>
<li>
<b>
#24 Fail to infer the type argument when using nested diamond operator  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10698">https://issues.apache.org/jira/browse/GROOVY-10698</a>
<br>
<b>Date found</b>:
2022-07-21
<br>
<b>Status</b>:
Resolved
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-07-24
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  A(T x, B<T> y) {}
}
class B<X> {}
class Test {
  void test() {
    new A<>("fda", new B<>())
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Type argument inference, Parameterized class, Parameterized type

<br>
<br>
</details>
</li>
<li>
<b>
#25 STC crashes when combining use-site variance with bounded polymorphism  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10674">https://issues.apache.org/jira/browse/GROOVY-10674</a>
<br>
<b>Date found</b>:
2022-06-29
<br>
<b>Status</b>:
Resolved
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-07-24
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
class Main {
  static Foo<Bar<Byte, Byte>, ? super Bar<Byte, Byte>> foo = new Foo<>(new Bar<>())
}
class Bar<T extends Number, S extends T> {}
class Foo<M extends Bar<Byte, ? extends Byte>, D extends M> {
  D x
  public Foo(D x) {
    this.x = x
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Bounded type parameter, Use-site variance, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#26 Fail to substitute type variable when encountering conflicting type parameter with a bound  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10662">https://issues.apache.org/jira/browse/GROOVY-10662</a>
<br>
<b>Date found</b>:
2022-06-20
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-06-21
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<X, T> {
  A(T p1, X p2) {}
  void foo(X x) {}
}
class B<T extends Number> {
  void test() {
    T x = (T) null;
    Character y = (Character) 'd';
    new A<>(y, x).foo((T) null);
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Type argument inference, Bounded type parameter

<br>
<br>
</details>
</li>
<li>
<b>
#27 Invalid type substitution when encountering bounded type parameter and the diamond operator  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10633">https://issues.apache.org/jira/browse/GROOVY-10633</a>
<br>
<b>Date found</b>:
2022-05-20
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-06-21
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T, Y> {
  B<Y> f;
  A(B<Y> x, T y) {}
}
class B<T> {
  void m(T x) {}
}
class Test {
  <T extends Number> void test() {
    def x = new B<T>();
    new A<>(x, "").f.m((T) null);
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Parameterized function, Bounded type parameter, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#28 Nested diamond operators do not work correctly although the expected type argument is known  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10624">https://issues.apache.org/jira/browse/GROOVY-10624</a>
<br>
<b>Date found</b>:
2022-05-13
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-05-17
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class C<T> {
  C(D<T> x) {}
}
class D<T> {}
class Test {
  void test() {
    C<Float> x = new C<>(new D<>()); // type variables are instantiated with type Float because of the left-hand side.
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#29 Type mismatch when encountering unconditional flow typing and null  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10623">https://issues.apache.org/jira/browse/GROOVY-10623</a>
<br>
<b>Date found</b>:
2022-05-13
<br>
<b>Status</b>:
Resolved
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-05-15
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A {}
class Test {
  void test() {
    def x = new A() // type of x is A
    x = null; // type of x becomes Object
    A y = x
  }
  void test2() {
    def x = new A()
    if (true) {
      x = null
    }
    A y = x // compiles as expected
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Flow typing

<br>
<br>
</details>
</li>
<li>
<b>
#30 Fail to infer the correct type argument when having conditionals and diamond operator 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10614">https://issues.apache.org/jira/browse/GROOVY-10614</a>
<br>
<b>Date found</b>:
2022-04-30
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo<T> {}
class Test {
  public static void test() {
    foo((true) ? new Foo<Boolean>() : new Foo<>());
  }
  public static void foo(Foo<Boolean> x) {}
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Conditionals, Type argument inference, Parameterized class, Parameterized type

<br>
<br>
</details>
</li>
<li>
<b>
#31 Incomplete type variable substitution when using wildcard type and diamond operator  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10499">https://issues.apache.org/jira/browse/GROOVY-10499</a>
<br>
<b>Date found</b>:
2022-02-17
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-03-13
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo<T> {
  Foo(T x) {}
}
class Bar<T> {
  Bar(Foo<? extends T> foo, T p) {
  }
  T m(T x) {
    return null;
  }
}
public class Test<T>  {
  void test() {
    T x = null;
    new Bar<>(new Foo<T>(x), x).m(x);
  }  
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Bounded type parameter, Parameterized type, Parameterized class, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#32 Closure that assigns null to object changes the type of variable 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10480">https://issues.apache.org/jira/browse/GROOVY-10480</a>
<br>
<b>Date found</b>:
2022-02-15
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Duplicate
<br>
<b>Resolution date</b>:
2022-02-15
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo {
  void foo() {}
}
class Main  {
  static void bar() {
    def x = new Foo();
    if (false) {
      x = null;
    }
    x.foo(); // works
  }
  static void baz() {
    def x  = new Foo();
    def clos = { -> {
      x = null;
    }}
    x.foo(); // fails
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Flow typing, Lambda, Variable type inference

<br>
<br>
</details>
</li>
<li>
<b>
#33 STC fails to instantiate type variable when using diamond operator  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10368">https://issues.apache.org/jira/browse/GROOVY-10368</a>
<br>
<b>Date found</b>:
2021-11-15
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-03-15
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T extends Number> {
  A(String x) {}
}
class B {
  void m(A<Integer> x) {}
}
class Test {
  void test() {
    B x = new B();
    x.m(new A<>(""));
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Bounded type parameter, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#34 STC fails to infer the correct type for type variable in the presence of the diamond operator and bounded polymorphism  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10367">https://issues.apache.org/jira/browse/GROOVY-10367</a>
<br>
<b>Date found</b>:
2021-11-15
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-03-15
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<Z, P extends Z> {
  Z f;
  A(Z f) {}
}
class B<Z extends Number> {
  Z f;
  void test() {
    f = new A<>((Z) null).f;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Bounded type parameter, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#35 STC changes the inferred type of variable in the presence of flow typing  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10356">https://issues.apache.org/jira/browse/GROOVY-10356</a>
<br>
<b>Date found</b>:
2021-11-10
<br>
<b>Status</b>:
Resolved
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-05-15
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
interface A {
  void a();
}
class Test {
  void test_closure() {
    def a = (A) null;
    def x = { ->
      a = null;
    }
    a.a();
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Variable type inference, Flow typing, Lambda

<br>
<br>
</details>
</li>
<li>
<b>
#36 Wrong type argument is inferred on combining use-site variance and diamond operator  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10351">https://issues.apache.org/jira/browse/GROOVY-10351</a>
<br>
<b>Date found</b>:
2021-11-08
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-11-09
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  A(T f, B<T, ? extends T> x){  } 
}
class B<T1, T2> {}
class Test {
  void test() {
    B<Integer, ? extends Integer> x = null;
    A<Integer> y = new A<>(1, x);
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Use-site variance, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#37 STC crashes when bound has two wildcard types as type arguments  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10344">https://issues.apache.org/jira/browse/GROOVY-10344</a>
<br>
<b>Date found</b>:
2021-11-03
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-11-04
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
@groovy.transform.CompileStatic
class Main {
  public static final void main() {
    final def x = ((B) null).foo(new A<>(), new A<>())
  }
}
class A<O, S> {}
interface B {
  abstract <F_P extends A<? extends Number, ? extends Number>> void foo(F_P y, F_P z)
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Variable type inference, Type argument inference, Parameterized function, Bounded type parameter, Use-site variance

<br>
<br>
</details>
</li>
<li>
<b>
#38 STC fails to infer dependent type variable  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10343">https://issues.apache.org/jira/browse/GROOVY-10343</a>
<br>
<b>Date found</b>:
2021-11-03
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-05-16
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T1, T2 extends T1> {
  T1 f;
  A(T1 f) {
    this.f = f;
  }
  T2 foo() { return null; }
}
class Test {
  void test() {
    Integer x = 1;
    var y = new A<>(x).foo();
    Integer z = y;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Bounded type parameter, Variable type inference, Parameterized type, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#39 STC is unable to infer type parameter of parameterized method call  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10342">https://issues.apache.org/jira/browse/GROOVY-10342</a>
<br>
<b>Date found</b>:
2021-11-03
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-05-19
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  T f;
}
class Test {
  static <T> T m() { return null; }
  static <T extends Number> void test() {
    String x = m(); // works
    A<String> y = new A<>();
    y.f = m(); // works
    A<T> z = new A<T>();
    z.f = m(); // does not work
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized function, Bounded type parameter, Parameterized type, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#40 STC is unable to infer type variable when combining parameterized types and the diamond operator  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10324">https://issues.apache.org/jira/browse/GROOVY-10324</a>
<br>
<b>Date found</b>:
2021-10-21
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-11-01
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A {
  <T> T foo(C<T> t) { return null; }
}
class C<T> {}
class B {
  void test() {
    C<String> x = (new A()).foo(new C<>());
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#41 Type variable inference does not work properly in nested diamond operators  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10316">https://issues.apache.org/jira/browse/GROOVY-10316</a>
<br>
<b>Date found</b>:
2021-10-18
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-05-17
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  T f;
  A(T f) {
    this.f = f;
  }
}
class B<T> {
  A<T> f;
  B(A<T> f) {
    this.f = f;
  }
}
class Test {
  void test() {
    def x = new  B<>(new A<>((long) 1)).f;
    A<Long> y = x;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Type argument inference, Variable type inference

<br>
<br>
</details>
</li>
<li>
<b>
#42 STC is unable to call parameterized function  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10310">https://issues.apache.org/jira/browse/GROOVY-10310</a>
<br>
<b>Date found</b>:
2021-10-15
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-11-02
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  T f;
  A(T f) {
    this.f = f;
  }
  A() {}
}
class B<T> {}
class Test {
  static <T> A<T> test(T x, B<? extends T> z) {
    return new A<>(x);
  }
  public static void main(String[] args) {
    var d = "d";
    test(d, new B<>());
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Parameterized function, Use-site variance, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#43 SC incorrectly reports "access to Object#field" is forbidden  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10308">https://issues.apache.org/jira/browse/GROOVY-10308</a>
<br>
<b>Date found</b>:
2021-10-15
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-10-24
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  T p
}
@groovy.transform.CompileStatic
void test() {
  def x = { -> new A<String>() }
  def y = x()
  def z = y.p
  y = null // changes inferred type
}
test()
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Lambda, Variable type inference
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/72c791402f'>https://github.com/apache/groovy/commit/72c791402f</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#44 Variable's inferred type is upcasted to an Object  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10294">https://issues.apache.org/jira/browse/GROOVY-10294</a>
<br>
<b>Date found</b>:
2021-10-11
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-10-31
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A {
  A foo() {
    def x = new A()
    if (false) {
      x = null
    }
    x
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Variable type inference, Flow typing

<br>
<br>
</details>
</li>
<li>
<b>
#45 STC fails to substitute type variable when using the diamond operator and calling a closure  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10291">https://issues.apache.org/jira/browse/GROOVY-10291</a>
<br>
<b>Date found</b>:
2021-10-08
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-11-02
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<X> {
  X x;
  A(X x) {
    this.x = x
  }
}
class Test<T> {
  void foo() {
    def closure = { T p -> "" }
    T y = null
    bar(new A<>(y).x) // works
    closure(new A<>(y).x) // fails
  }
  void bar(T x) {} 
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Lambda, Type argument inference, Variable type inference

<br>
<br>
</details>
</li>
<li>
<b>
#46 STC: Stackoverflow Error when passing function reference to closure  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10269">https://issues.apache.org/jira/browse/GROOVY-10269</a>
<br>
<b>Date found</b>:
2021-09-28
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-10-12
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.function.Consumer;
@groovy.transform.TypeChecked
class Test {
  static final void foo(Integer y) {}
  static final void bar(Consumer<Integer> x) {}
  public static void main () {
    def qux = { Consumer<Integer> x -> }
    Test.bar(Test::foo) // OK
    qux(Test::foo) // Crashes
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Function type, Function reference, Variable type inference, Lambda
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/5864765e58'>https://github.com/apache/groovy/commit/5864765e58</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#47 The diamond operator does not work when passing a value whose type is a type variable  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10266">https://issues.apache.org/jira/browse/GROOVY-10266</a>
<br>
<b>Date found</b>:
2021-09-27
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-05-18
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  void foo() {
    T z = null;
    T x = new B<>(z).f // does not work
    String y = ""
    String k = new B<>(y).f // works
  }
}
class B<X> {
  X f;
  B(X f) {
    this.f = f;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Type argument inference, Parameterized type

<br>
<br>
</details>
</li>
<li>
<b>
#48 STC is unable to resolve variable in closure 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10265">https://issues.apache.org/jira/browse/GROOVY-10265</a>
<br>
<b>Date found</b>:
2021-09-27
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Information Provided
<br>
<b>Resolution date</b>:
2021-10-31
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
import java.util.function.Supplier;
class B {
  Supplier<Integer> m2() {
    final def x = 1
    { -> x + 1 }
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Function type, Variable type inference, Lambda

<br>
<br>
</details>
</li>
<li>
<b>
#49 Issue with the diamond operator and conditional 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10264">https://issues.apache.org/jira/browse/GROOVY-10264</a>
<br>
<b>Date found</b>:
2021-09-27
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Duplicate
<br>
<b>Resolution date</b>:
2021-09-27
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T extends Number> {
  T foo() {
    T x = null;
    (true) ?
      new B<>(x).f: new B<>(x).f
  }
}
class B<X> {
  X f;
  B(X x) {
    this.f = f;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Bounded type parameter, Conditionals, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#50 STC fails to substitute type variable in the presence of the diamond operator and a function call  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10228">https://issues.apache.org/jira/browse/GROOVY-10228</a>
<br>
<b>Date found</b>:
2021-09-13
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-11-02
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  T x;  A(T x) {
    this.x = x;
  }
  T getX() {
    return x;
  }
}
class B {}
class Main {
  public static void m1() {
    def x = new B();
    m2(new A<>(x).getX());
  }  public static void m2(B x) {}
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#51 Unexpected compile-time error when combining closures and bounded type parameters  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10221">https://issues.apache.org/jira/browse/GROOVY-10221</a>
<br>
<b>Date found</b>:
2021-09-10
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-03-14
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T1, T2 extends T1> {
  void foo() {
    def cls1 = { T2 x -> "" }
    Closure<T2> cls2 = { T2 x -> x }
    cls1(cls2((T2) null))
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Bounded type parameter, Function type, Lambda, Variable type inference

<br>
<br>
</details>
</li>
<li>
<b>
#52 Wrong type argument inference when using the result of ternary operator directly.  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10114">https://issues.apache.org/jira/browse/GROOVY-10114</a>
<br>
<b>Date found</b>:
2021-05-27
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2022-03-15
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
@groovy.transform.TypeChecked
class Test {
  public static void main(String[] args) {
    def x = ((false) ? new B<>(new A()) : new B<>(new A()))
    x.bar.foo()
    ((false) ? new B<A>(new A()) : new B<>(new A())).bar.foo()
    ((false) ? new B<>(new A()) : new B<>(new A())).bar.foo()
  }
}
final class A {
  public A() {
  }
  final Character foo() {
    (Character) 'g'
  }
}
class B<V> {
  public V bar
  public B(V bar) {
    this.bar = bar
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Type argument inference, Conditionals, Parameterized type, Parameterized class

<br>
<br>
</details>
</li>
<li>
<b>
#53 Closure with type argument inference does not work as expected  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10080">https://issues.apache.org/jira/browse/GROOVY-10080</a>
<br>
<b>Date found</b>:
2021-05-11
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-05-11
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
@groovy.transform.CompileStatic
public class Main {
  public static void main(String[] args) {
    def closure = {
      new Bar<>(new Foo<Long>());
    }
    closure().f.m(new BigDecimal[0]) // this doesn't work
    // the following works
    // Bar<Foo<Long>> x = closure()
    // x.f.m(new BigDecimal[0]);
  }
}
class Foo<X> {
  void m(Object[] x) {}
}
class Bar<X> {
  X f;
  Bar(X f) {
    this.f = f;
  }
}
class Baz {}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Type argument inference, Lambda, Parameterized class, Parameterized type, Array, Subtyping
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/ad29de380a'>https://github.com/apache/groovy/commit/ad29de380a</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#54 Combining flow typing and type argument inference does not work as expected  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-10011">https://issues.apache.org/jira/browse/GROOVY-10011</a>
<br>
<b>Date found</b>:
2021-04-05
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-04-10
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  T f;
  public A(T f) {
    this.f = f;
  }
}
class Foo {}
class Bar extends Foo {}
public class Main {
  public static void bar(Foo x) {
    if (x instanceof Bar) {
      A<Bar> a = new A<>(x)
    }
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Inheritance / Implementation of multiple interfaces, Type argument inference, Flow typing
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/131728feed'>https://github.com/apache/groovy/commit/131728feed</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#55 Cannot infer correct type argument when using subtyping  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9996">https://issues.apache.org/jira/browse/GROOVY-9996</a>
<br>
<b>Date found</b>:
2021-03-22
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-25
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
@groovy.transform.CompileStatic
public class Main {
  public static void main(String[] args) {
    Foo foo = new Bar()
    def x = new A<>(foo)
    bar(x)
  }
  public static void bar(A<Foo> f) {}
}
class A<T> {
  T f;
  public A(T f) {
    this.f = f;
  }
}
class Foo {}
class Bar extends Foo {}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Type argument inference, Inheritance / Implementation of multiple interfaces, Variable type inference, Subtyping
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/f75622b77e'>https://github.com/apache/groovy/commit/f75622b77e</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#56 Wrong inference inside closure when having a bounded type parameter  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9995">https://issues.apache.org/jira/browse/GROOVY-9995</a>
<br>
<b>Date found</b>:
2021-03-22
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-24
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
@groovy.transform.CompileStatic
public class Main {
  public static void main(String[] args) {
    Closure<A<Long>> closure =  { -> {
      final x = (Long) 1;
      new A<>(x);
    }}
    // If I remove 'extends Number' in class A, the following code
    // works as expected.
    final Long y = closure().f;
  }
}
class A<T extends Number> {
  T f;
  public A(T f) {
    this.f = f;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Bounded type parameter, Type argument inference, Lambda, Function type
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/39422ed19b'>https://github.com/apache/groovy/commit/39422ed19b</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#57 Wrong type inference when passing null  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9984">https://issues.apache.org/jira/browse/GROOVY-9984</a>
<br>
<b>Date found</b>:
2021-03-15
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-21
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
@groovy.transform.CompileStatic
public class Main {
  public static void main(String[] args) {
    final A<Integer> x = new A<>(null);
    baz(x);
  }
  public static void baz(A<Integer> x) {}
}
class A<T> {
  T f;
  public A(T f) {
    this.f = f;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Type argument inference
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/734ea3bdc3'>https://github.com/apache/groovy/commit/734ea3bdc3</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#58 Type argument inference does not work in ternary operator  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9983">https://issues.apache.org/jira/browse/GROOVY-9983</a>
<br>
<b>Date found</b>:
2021-03-15
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-05-16
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
@groovy.transform.CompileStatic
public class Test {
  public static void main(String[] args) {
      final A<B> x = (true ? new A<>(new B()): new A<>(new C()))
      bar(x) // compiles
      bar((true ? new A<>(new B()): new A<>(new C()))) // does not compile
  }
  public static void bar(A<B> x) {}
}
class A<T> {
  T f;
  public A(T f) {
    this.f = f;
  }
}
class B {}
class C extends B{}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Inheritance / Implementation of multiple interfaces, Subtyping, Type argument inference, Conditionals
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/3e279e5d8e'>https://github.com/apache/groovy/commit/3e279e5d8e</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#59 LUB does not work correctly in case of ternary operator  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9972">https://issues.apache.org/jira/browse/GROOVY-9972</a>
<br>
<b>Date found</b>:
2021-03-08
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-15
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo {
  public String x = "f";
}
class A<T> {
  public T f;
  A(T f) {
    this.f = f;
  }
}
public class Main {
  public static void foo() {
    def temp;
    if (true) {
      temp = new A<>(new Foo());
    } else {
      temp = new A<>(new Foo());
    }
    temp.f.x.toLowerCase() // works  fine
  }
  public static void bar() {
    A<Foo> temp = true ? new A<>(new Foo()) : new A<>(new Foo())
    temp.f.x // does not compile;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Type argument inference, Conditionals
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/5591f88592'>https://github.com/apache/groovy/commit/5591f88592</a>
</li>
<li>
<a href='https://github.com/apache/groovy/commit/49a6aa5849'>https://github.com/apache/groovy/commit/49a6aa5849</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#60 Type argument inference does not work in closure  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9970">https://issues.apache.org/jira/browse/GROOVY-9970</a>
<br>
<b>Date found</b>:
2021-03-08
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-15
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo {}
final class A<T extends Foo> {
  public T x;
  A(T x) {
    this.x = x;
  }
}
@groovy.transform.CompileStatic
public class C<T extends Number> {
  public void foo(T args) {
    final A<Foo> x = new A<>(new Foo()); // compiles
    def closure = p -> {
        final A<Foo> y = new A<>(new Foo()); // does not compile
    }
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Bounded type parameter, Lambda, Type argument inference
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/818f3d8842'>https://github.com/apache/groovy/commit/818f3d8842</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#61 Generic type of field is not instantiated  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9963">https://issues.apache.org/jira/browse/GROOVY-9963</a>
<br>
<b>Date found</b>:
2021-03-03
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-07
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  T x;
  A(T x) {
    this.x = x;
  }
}
public class Main {
  public static void main(String[] args) {
    bar((new A<>("")).x);
  }
  public static void bar(String x) {}
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Type argument inference
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/2a27ee8df0'>https://github.com/apache/groovy/commit/2a27ee8df0</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#62 Cannot infer correct type argument when passing a subtype of the declared type argument  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9956">https://issues.apache.org/jira/browse/GROOVY-9956</a>
<br>
<b>Date found</b>:
2021-02-26
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-03
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo<T> {
    T f;
    Foo (T f) {
      this.f = f;
    }
}
interface Bar{}
class Baz<T> implements Bar {}
@groovy.transform.TypeChecked
class Main  {
  public static void main(String[] args) {
    Foo<Bar> x1 = new Foo<Bar>(new Baz<Integer>()) // Compiles
    Foo<Bar> x2 = new Foo<>(new Baz<Integer>()) // Does not compile
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Subtyping, Inheritance / Implementation of multiple interfaces, Parameterized type, Type argument inference
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/715c34edc8'>https://github.com/apache/groovy/commit/715c34edc8</a>
</li>
<li>
<a href='https://github.com/apache/groovy/commit/d1b28b0ab9'>https://github.com/apache/groovy/commit/d1b28b0ab9</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#63 Type from flow typing is not propagated in variable assignments  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9953">https://issues.apache.org/jira/browse/GROOVY-9953</a>
<br>
<b>Date found</b>:
2021-02-24
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-02
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A {}
@groovy.transform.CompileStatic
class Main {
  static A bar(Object x) {
    if (x instanceof A) {
      def y = x // Inferred Object and not A
      y
    } else {
      new A()
    }
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Variable type inference, Flow typing, Conditionals
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/3a3d5b70bd'>https://github.com/apache/groovy/commit/3a3d5b70bd</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#64 Cannot infer the correct type in the presence of diamond operator  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9948">https://issues.apache.org/jira/browse/GROOVY-9948</a>
<br>
<b>Date found</b>:
2021-02-17
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-02
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo<T> {
    T f;
    Foo (T f) {
      this.f = f;
    }
}
class Main  {
  public static void main(String[] args) {
      Foo<Integer> x = new Foo<>(1);
      assert x.f < 10 == true; // does not compile
      m(x);
  }  public static void m(Foo<Integer> x) {
      assert x.f < 10 == true; // compiles fine
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Type argument inference
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/566c832c02'>https://github.com/apache/groovy/commit/566c832c02</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#65 int reference seems to not use its wrapper class  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9935">https://issues.apache.org/jira/browse/GROOVY-9935</a>
<br>
<b>Date found</b>:
2021-02-10
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-02
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
@groovy.transform.TypeChecked
class Foo {
  static Number foo() {
    def i = 10  // If I use: `Integer i = 10` it works
    return i
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Variable type inference, Subtyping
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/da47adb15b'>https://github.com/apache/groovy/commit/da47adb15b</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#66 Bounded type parameter is not captured by closure  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9934">https://issues.apache.org/jira/browse/GROOVY-9934</a>
<br>
<b>Date found</b>:
2021-02-09
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-02
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Bar {}
class Foo<T extends Bar> {
  public T method(T x) {
    def bar = {x}
    return bar()
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Bounded type parameter, Variable type inference, Lambda

<br>
<br>
</details>
</li>
<li>
<b>
#67 Type tracked from instanceof condition is not captured in closure  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://issues.apache.org/jira/browse/GROOVY-9907">https://issues.apache.org/jira/browse/GROOVY-9907</a>
<br>
<b>Date found</b>:
2021-01-25
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-03-02
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
@groovy.transform.TypeChecked
class Test {
  public static void main(String[] args) {
    println(foo(10));
  }
  static Integer foo(Object x) {
    if (x instanceof Integer) {
      def bar = {x};
      return bar();
    }
    return 100;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Lambda, Flow typing, Variable type inference
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/apache/groovy/commit/967c81c31e'>https://github.com/apache/groovy/commit/967c81c31e</a>
</li>

</ul>

<br>
<br>
</details>
</li>
</ul>

<h3>Kotlin</h3>

<ul>
<li>
<b>
#68 Unexpected callable reference ambiguity when having a private overloading method 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-58776">https://youtrack.jetbrains.com/issue/KT-58776</a>
<br>
<b>Date found</b>:
2023-05-18
<br>
<b>Status</b>:

<br>
<b>Resolution</b>:
As Designed
<br>
<b>Resolution date</b>:
2023-05-22
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
kt
//     implementation("com.google.guava:guava:31.1-jre")
fun test(): Unit
{
  val x: List<String> = TODO()
  val map: com.google.common.collect.HashBiMap<String, String> = TODO()
  val res = x.reduceRight(map::put)
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Function reference, Overloading, Access modifier, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#69 Type mismatch when resolving wrong overloaded function 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-57596">https://youtrack.jetbrains.com/issue/KT-57596</a>
<br>
<b>Date found</b>:
2023-03-27
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
kt
fun test() {
    val tmp: Iterable<HashSet<Number>> = TODO()
    val p: HashSet<Number> = TODO()
    val x: List<HashSet<Number>> = tmp - p
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Operator, Overloading, Parameterized function, Parameterized type, Parameterized class, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#70 Condition adds covariance to inferred type argument and leads to type mismatch error 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-57226">https://youtrack.jetbrains.com/issue/KT-57226</a>
<br>
<b>Date found</b>:
2023-03-09
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
kt
import java.util.function.*;
import java.util.stream.*;
fun test(x: ToIntFunction<String>, y: ToIntFunction<Any>): Unit 
{
    val z: Collector<String, *, Double?> = Collectors.averagingInt(
        if (false) x else y)
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Conditionals, Wildcard type, Parameterized type, Parameterized class, Parameterized function

<br>
<br>
</details>
</li>
<li>
<b>
#71 No smart cast when returning function closures with captured smart-cast variable 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-43846">https://youtrack.jetbrains.com/issue/KT-43846</a>
<br>
<b>Date found</b>:
2020-12-09
<br>
<b>Status</b>:
Submitted


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
fun foo(x: Any): String {
    if (x is String) {
        val thunk = {x}
        return thunk()
    }
    return "str"
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Flow typing, Variable type inference, Lambda

<br>
<br>
</details>
</li>
<li>
<b>
#72 AssertionError: Variance conflict: type parameter variance 'out' and projection kind 'in' cannot be combined 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-49024">https://youtrack.jetbrains.com/issue/KT-49024</a>
<br>
<b>Date found</b>:
2021-09-30
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
class Foo
class Bar<T1: Foo, out T2>
class Baz<T1, T2: Bar<Foo, out T2>>
class Qux<T1, T2: Baz<T2, Bar<Foo, T2>>>(var f: T2)
class Quux<T> {
  fun test(): Unit {
      val x: Qux<in T, Baz<T, Bar<Foo, in T>>> = TODO()
      x.f = TODO()
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Bounded type parameter, Declaration-site variance, Variable type inference, Use-site variance

<br>
<br>
</details>
</li>
<li>
<b>
#73 NI: Compile-time error when combining anonymous function and lambda in a conditional 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-48764">https://youtrack.jetbrains.com/issue/KT-48764</a>
<br>
<b>Date found</b>:
2021-09-15
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
fun test(x: Function<Any>): Unit {}
fun main() {
    val x: Function<Any> = (
        if (true) {x: String, y: String -> x + y}
        else fun(x: String) = x
    ) // this works
    test(
        if (true) { x: String, y: String -> x + y}
        else fun(x: String) = x
    ) // this does not work
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Function type, Lambda, Return type inference, Subtyping

<br>
<br>
</details>
</li>
<li>
<b>
#74 NI: Can not infer type of an if expression when passed in a function call and used a type parameter variable 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-47184">https://youtrack.jetbrains.com/issue/KT-47184</a>
<br>
<b>Date found</b>:
2021-06-08
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Test<T: Byte> {
    fun test(z: T) {
        val y: Byte = if (true) z else 1 // works
        val x = bar(if (true) z else 1) // fails
    }
    fun bar(x: Byte) {}
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Bounded type parameter, Variable type inference

<br>
<br>
</details>
</li>
<li>
<b>
#75 Wrong java.io.Serializable inferred 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-44742">https://youtrack.jetbrains.com/issue/KT-44742</a>
<br>
<b>Date found</b>:
2021-02-05
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
fun main() {
    val x = if (true) 1 as Number else false // inferred type is java.io.Serializable
    x == 1
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Subtyping, Conditionals

<br>
<br>
</details>
</li>
<li>
<b>
#76 Can not infer type of overridden function 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-44082">https://youtrack.jetbrains.com/issue/KT-44082</a>
<br>
<b>Date found</b>:
2020-12-24
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
interface R<T>
interface W
interface J
open class A
open class B: A(), R<W>
open class E: A(), R<J>
open class C {
    open fun foo(): A = B()
}
class D: C() {
    override fun foo() = if (true) B() else E()
}
val x = if (true) B() else E() // Inferred type of x is Any
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Inheritance / Implementation of multiple interfaces, Subtyping, Return type inference, Overriding, Conditionals

<br>
<br>
</details>
</li>
<li>
<b>
#77 JVM: ArrayIndexOutOfBoundsException on compiling call with `if` expression and TODO() arguments  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-49092">https://youtrack.jetbrains.com/issue/KT-49092</a>
<br>
<b>Date found</b>:
2021-10-05
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-12-22
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
class A {
    fun foo(x: Any, y: CharArray): Boolean = true
}
val x: A = A()
val y: Boolean = true
val z: Long = -61
val k = x.foo((if (y) z else Any()), TODO())
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Array, Conditionals, Variable type inference

<br>
<br>
</details>
</li>
<li>
<b>
#78 ClassCastException caused by parent and child class in if-else  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-45118">https://youtrack.jetbrains.com/issue/KT-45118</a>
<br>
<b>Date found</b>:
2021-02-22
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-09-29
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
open class Foo(open val x: Boolean)
class Bar: Foo(false)
fun contract(x: Foo) =
  x
val temp = if (true) contract(Bar()) else Bar()
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Return type inference, Inheritance / Implementation of multiple interfaces, Conditionals, Subtyping
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/JetBrains/kotlin/commit/b5661ccabd8'>https://github.com/JetBrains/kotlin/commit/b5661ccabd8</a>
</li>

</ul>

<br>
<br>
</details>
</li>
<li>
<b>
#79 Cannot infer type of overridden function with generic 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-44595">https://youtrack.jetbrains.com/issue/KT-44595</a>
<br>
<b>Date found</b>:
2021-01-28
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
As Designed
<br>
<b>Resolution date</b>:
2021-09-08
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class X<T> (val x: T)
open class A {
    open fun foo(): X<A> =
       X(A())
} 
class B: A() {
    override fun foo() =
      X(B())
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Inheritance / Implementation of multiple interfaces, Overriding, Type argument inference, Return type inference

<br>
<br>
</details>
</li>
<li>
<b>
#80 Imprecise type is inferred in an if expression 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-44551">https://youtrack.jetbrains.com/issue/KT-44551</a>
<br>
<b>Date found</b>:
2021-01-26
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
As Designed
<br>
<b>Resolution date</b>:
2021-09-08
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
   open class A
   open class B: A()
   class X<T: A>(val x: T)
   fun foo(x: X<A>) = {}
   val tmp = if (true) X<A>(A()) else X(B())
   fun main() {
       foo(tmp)
   }
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Inheritance / Implementation of multiple interfaces, Bounded type parameter, Subtyping, Conditionals, Type argument inference, Variable type inference

<br>
<br>
</details>
</li>
<li>
<b>
#81 ClassCastException when calling a function with a nullable generic vararg parameter 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-46684">https://youtrack.jetbrains.com/issue/KT-46684</a>
<br>
<b>Date found</b>:
2021-05-14
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Duplicate
<br>
<b>Resolution date</b>:
2021-05-14
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
class Test {
    fun foo() {
        m("str", null);
    }
    fun <T: Number> m(obj: Any, vararg t: T?) {
        println("here")
    }
}
fun main() {
    Test().foo()
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Bounded type parameter, Parameterized function, Type argument inference, Variable argument

<br>
<br>
</details>
</li>
<li>
<b>
#82 JVM / IR: "IllegalStateException: Illegal type substitutor" with if-else inside class constructor argument inside another if-else  -- Fixed
</b>

<details>
<br>
<b>Link</b>:
<a href="https://youtrack.jetbrains.com/issue/KT-44651">https://youtrack.jetbrains.com/issue/KT-44651</a>
<br>
<b>Date found</b>:
2021-02-01
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Fixed
<br>
<b>Resolution date</b>:
2021-02-11
<br>
<b>Symptom</b>:
Crash
<br>
<b>Test case</b>:
<pre>
<xmp>
class X<T: Number>(val y: Any, val x: T)
fun main() {
  val num: Long = -10
  val num2: Int = 20
  val obj = if (true)
      X(Any(), if (true) num else num2)
    else
      X(Any(), -25)
   val f = obj.y
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Bounded type parameter, Parameterized type, Type argument inference, Variable type inference, Conditionals
<br>
<b>Fix Commit(s)</b>:
<ul>
<li>
<a href='https://github.com/JetBrains/kotlin/commit/f797ee78035'>https://github.com/JetBrains/kotlin/commit/f797ee78035</a>
</li>

</ul>

<br>
<br>
</details>
</li>
</ul>

<h3>Scala</h3>

<ul>
<li>
<b>
#83 Conversion of function type to SAM results in unexpected type mismatch 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://github.com/lampepfl/dotty/issues/17348">https://github.com/lampepfl/dotty/issues/17348</a>
<br>
<b>Date found</b>:
2023-04-25
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
Scala
def m[U](p: java.util.function.IntFunction[? <: U]): Unit = {}
def test(): Unit = {
  val y = "d"
  m((p) => y.asInstanceOf[Any])
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Single Abstract Method (SAM), Lambda, Wildcard type, Parameterized type, Parameterized class, Parameterized function, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#84 The inferred type is not precise when omitting type argument in the receiver expression 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://github.com/lampepfl/dotty/issues/17311">https://github.com/lampepfl/dotty/issues/17311</a>
<br>
<b>Date found</b>:
2023-04-19
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
Scala
import java.util.Comparator
class Foo[E](x: java.util.Comparator[? >: E]) {
  def first(): E = ???
}
class Bar {
  def m(): String = ""
}
def test(): Unit =
{
  val x: java.util.Comparator[Bar] = ???
  val y = new Foo(x)
  val z = y.first()
  z.m() // succeeds
  val k = new Foo(x).first()
  k.m() // fails
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized type, Parameterized class, Wildcard type, Type argument inference

<br>
<br>
</details>
</li>
<li>
<b>
#85 Unexpected error when boxing LongStream and using reduce 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://github.com/lampepfl/dotty/issues/17207">https://github.com/lampepfl/dotty/issues/17207</a>
<br>
<b>Date found</b>:
2023-04-04
<br>
<b>Status</b>:
Open


<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
Scala
import java.util.stream._;
import java.util.function._;
def test(): Unit = {
  val x: BinaryOperator[Long] = ???
  val y: LongFunction[Long] = ???
  val rec: LongStream = ???
  rec.mapToObj(y).reduce(43, x) // fails
  val z = rec.mapToObj(y) 
  z.reduce(43, x) // succeeds
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Single Abstract Method (SAM), Parameterized function, Parameterized type, Parameterized class, Type argument inference, Primitive type

<br>
<br>
</details>
</li>
</ul>

<h3>Java</h3>

<ul>
<li>
<b>
#86 Wrong Type-Argument inference in presence of bounds and use-site variance 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://bugs.openjdk.java.net/browse/JDK-8269737">https://bugs.openjdk.java.net/browse/JDK-8269737</a>
<br>
<b>Date found</b>:
2021-06-28
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Not an Issue
<br>
<b>Resolution date</b>:
2021-07-01
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
abstract class Cls<T1> {
  public Cls() {}
}
abstract class Cls2<T2> extends Cls<T2> {
  public Cls2() {}
}
abstract class Cls3<T3 extends Float> extends Cls2<T3> {
  public Cls3() {}
}
abstract class Cls4<T4 extends Cls3<? super Float>> {
  public Cls4() {}
}
final class Cls5 {
  public Cls5() {}
  public final Cls4<? extends Cls3<Float>> foo() {
    Cls4<? extends Cls3<Float>> y = (Cls4<? extends Cls3<Float>>) null;
    var x = y;
    // Cls4<? extends Cls3<Float>> x = y; // This works
    return x;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Bounded type parameter, Use-site variance, Inheritance / Implementation of multiple interfaces, Variable type inference

<br>
<br>
</details>
</li>
<li>
<b>
#87 Imprecise type inference in the presence of ternary operator and wildcard 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://bugs.openjdk.java.net/browse/JDK-8269386">https://bugs.openjdk.java.net/browse/JDK-8269386</a>
<br>
<b>Date found</b>:
2021-06-24
<br>
<b>Status</b>:
Closed
<br>
<b>Resolution</b>:
Not an Issue
<br>
<b>Resolution date</b>:
2021-06-28
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class A<T> {
  public A() {}
  public B<? super T> foo() {
    var x = (true) ? new B<T>() : (B<? super T>) null;
    return x;
    //return (true) ? new B<T>() : (B<? super T>) null;  // This works
  }
}
class B<T> {
  public B() {}
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Parameterized type, Use-site variance, Conditionals, Variable type inference

<br>
<br>
</details>
</li>
<li>
<b>
#88 Wrong type inference in presence of a generic with bound to Double 
</b>

<details>
<br>
<b>Link</b>:
<a href="https://bugs.openjdk.java.net/browse/JDK-8269348">https://bugs.openjdk.java.net/browse/JDK-8269348</a>
<br>
<b>Date found</b>:
2021-06-23
<br>
<b>Status</b>:
Resolved
<br>
<b>Resolution</b>:
Not an Issue
<br>
<b>Resolution date</b>:
2021-06-30
<br>
<b>Symptom</b>:
Unexpected compile-time error
<br>
<b>Test case</b>:
<pre>
<xmp>
class Test<T extends Double, K extends T> {
  public T test() {
    T foo = (T) null;
    final var v = ((true) ?
      foo :
       (K) null);
    return v;
  }
}
</xmp>
</pre>
<b>Test Case Characteristics</b>:
Parameterized class, Bounded type parameter, Conditionals, Variable type inference

<br>
<br>
</details>
</li>
</ul>



</body>
</html>
